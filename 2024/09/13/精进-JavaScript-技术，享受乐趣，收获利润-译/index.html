<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"toypipi.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万字长文吐血整理，建议点赞收藏，细细品味。 今天翻译的文章是 《Optimizing Javascript for fun and for profit》，作者 Rom Grk。文中深入探讨了 13 个不为人知的 JavaScript 高级优化技巧。通过实际案例和详细的解释，揭示了如何通过深入理解 JavaScript 引擎的工作原理来提升代码性能。同时，强调了基准测试的重要性，并">
<meta property="og:type" content="article">
<meta property="og:title" content="精进 JavaScript 技术，享受乐趣，收获利润[译]">
<meta property="og:url" content="https://toypipi.github.io/2024/09/13/%E7%B2%BE%E8%BF%9B-JavaScript-%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BA%AB%E5%8F%97%E4%B9%90%E8%B6%A3%EF%BC%8C%E6%94%B6%E8%8E%B7%E5%88%A9%E6%B6%A6-%E8%AF%91/index.html">
<meta property="og:site_name" content="Toypipi&#39;s blog">
<meta property="og:description" content="万字长文吐血整理，建议点赞收藏，细细品味。 今天翻译的文章是 《Optimizing Javascript for fun and for profit》，作者 Rom Grk。文中深入探讨了 13 个不为人知的 JavaScript 高级优化技巧。通过实际案例和详细的解释，揭示了如何通过深入理解 JavaScript 引擎的工作原理来提升代码性能。同时，强调了基准测试的重要性，并">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-13T02:33:15.000Z">
<meta property="article:modified_time" content="2024-09-25T04:55:42.335Z">
<meta property="article:author" content="toypipi">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="代码优化">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://toypipi.github.io/2024/09/13/%E7%B2%BE%E8%BF%9B-JavaScript-%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BA%AB%E5%8F%97%E4%B9%90%E8%B6%A3%EF%BC%8C%E6%94%B6%E8%8E%B7%E5%88%A9%E6%B6%A6-%E8%AF%91/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://toypipi.github.io/2024/09/13/%E7%B2%BE%E8%BF%9B-JavaScript-%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BA%AB%E5%8F%97%E4%B9%90%E8%B6%A3%EF%BC%8C%E6%94%B6%E8%8E%B7%E5%88%A9%E6%B6%A6-%E8%AF%91/","path":"2024/09/13/精进-JavaScript-技术，享受乐趣，收获利润-译/","title":"精进 JavaScript 技术，享受乐趣，收获利润[译]"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>精进 JavaScript 技术，享受乐趣，收获利润[译] | Toypipi's blog</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?c228072b8c3657dfa7236914b308712c"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Toypipi's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">0. 避免工作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="nav-number">2.</span> <span class="nav-text">1. 避免字符串比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%A2%E7%8A%B6"><span class="nav-number">3.</span> <span class="nav-text">2.避免不同的形状</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">3.避免数组 &#x2F; 对象方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="nav-number">5.</span> <span class="nav-text">4.避免间接访问</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="nav-number">6.</span> <span class="nav-text">5.避免缓存未命中</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%8F%96"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 预取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#l123-%E7%BC%93%E5%AD%98"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 L1&#x2F;2&#x2F;3 缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%A4%A7%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.</span> <span class="nav-text">6.避免大型对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-eval"><span class="nav-number">8.</span> <span class="nav-text">7.使用 eval</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">9.</span> <span class="nav-text">8.谨慎使用字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%93%E9%97%A8%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">9.使用专门化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">11.</span> <span class="nav-text">10.数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-number">12.</span> <span class="nav-text">11.基准测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%A4%A7%E5%9D%97%E5%BC%80%E5%A7%8B"><span class="nav-number">12.1.</span> <span class="nav-text">11.0 从大块开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-number">12.2.</span> <span class="nav-text">11.1 避免微基准测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%80%E7%96%91%E4%BD%A0%E7%BB%93%E6%9E%9C"><span class="nav-number">12.3.</span> <span class="nav-text">11.2 怀疑你结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E4%BD%A0%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">12.4.</span> <span class="nav-text">11.3 选择你的目标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="nav-number">13.</span> <span class="nav-text">12.分析和工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%99%B7%E9%98%B1"><span class="nav-number">13.1.</span> <span class="nav-text">12.1 浏览器陷阱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%87%E6%A0%B7%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-number">13.2.</span> <span class="nav-text">12.2 采样与结构化分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E4%B8%9A%E5%B7%A5%E5%85%B7"><span class="nav-number">13.3.</span> <span class="nav-text">12.3 行业工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-number">14.</span> <span class="nav-text">后记</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="toypipi"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">toypipi</p>
  <div class="site-description" itemprop="description">Stay focused, be present</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">308</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">404</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/toypipi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;toypipi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:275688469@qq.com" title="E-Mail → mailto:275688469@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toypipi.github.io/2024/09/13/%E7%B2%BE%E8%BF%9B-JavaScript-%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BA%AB%E5%8F%97%E4%B9%90%E8%B6%A3%EF%BC%8C%E6%94%B6%E8%8E%B7%E5%88%A9%E6%B6%A6-%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="toypipi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toypipi's blog">
      <meta itemprop="description" content="Stay focused, be present">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="精进 JavaScript 技术，享受乐趣，收获利润[译] | Toypipi's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          精进 JavaScript 技术，享受乐趣，收获利润[译]
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 10:33:15" itemprop="dateCreated datePublished" datetime="2024-09-13T10:33:15+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-25 12:55:42" itemprop="dateModified" datetime="2024-09-25T12:55:42+08:00">2024-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><hr />
<p>万字长文吐血整理，建议点赞收藏，细细品味。</p>
<p>今天翻译的文章是 <a
target="_blank" rel="noopener" href="https://romgrk.com/posts/optimizing-javascript#8-use-strings-carefully">《Optimizing
Javascript for fun and for profit》</a>，作者 Rom Grk。文中深入探讨了 13
个不为人知的 JavaScript
高级优化技巧。通过实际案例和详细的解释，揭示了如何通过深入理解
JavaScript
引擎的工作原理来提升代码性能。同时，强调了基准测试的重要性，并提供了一些工具和策略，帮助开发者进行基准测试。以下是文章的全文翻译：</p>
<p>我常常感觉，如果得到适当的优化，JavaScript
代码通常可以运行得更快。我在这里总结了一些有用的常见优化技术。需要注意的是，性能提升往往以可读性为代价，因此我把在性能和可读性之间做选择的问题留给读者。我还要指出，谈论优化就必然要谈论基准测试。如果一个函数在整体运行时间中只占很小一部分，那么花几个小时对其进行微调，使其运行速度提高
100
倍是没有意义的。如果正在进行性能优化，第一步也是最重要的一步是基准测试。我将在后面的要点中介绍这个话题。同时请注意，微基准测试通常是有缺陷的，这里介绍的也可能包括在内。我已经尽力避免这些陷阱，但在没有基准测试的情况下，不要盲目使用此处提出的任何要点。</p>
<span id="more"></span>
<p>我已经为所有可能的情况提供了可运行的示例。它们默认显示的是我使用 Arch
Linux 系统的 Brave 浏览器（版本
122）<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span
class="hint--top hint--error hint--medium hint--rounded hint--bounce"
aria-label="Brave 122 on Arch Linux 指的是在 Arch Linux 操作系统上运行的 Brave 浏览器版本 122。Brave 是一款注重隐私保护的网络浏览器，它通过屏蔽广告和追踪器来提高用户的隐私安全和浏览速度。
">[1]</span></a></sup>上得到的结果。尽管我不愿这么说，但 Firefox
在优化方面已经有点落后了，<a
target="_blank" rel="noopener" href="https://foundation.mozilla.org/en/?form=donate-header">目前</a>它在浏览器在市场份额（用户使用量）方面只占很小一部分，所以我不推荐将
Firefox 上得到的结果作为评估网站或应用性能的有效指标。</p>
<h1 id="避免工作">0. 避免工作</h1>
<p>这虽然显而易见但是至关重要，因为在优化中没有比这更早的步骤了：如果你正在尝试优化，你应该首先考虑避免工作（译者注：避免工作意味着在可能的情况下，不去执行不必要的计算或操作。这可能涉及到减少函数调用、避免重复计算、或者延迟计算直到真正需要结果的时候）。这包括记忆化（通过存储函数的中间结果，当同样的输入再次出现时，可以直接返回之前计算的结果，避免重复计算。）、惰性（延迟计算，直到结果真正需要时才进行。这样可以避免在某些情况下根本不需要的计算。）和增量计算（只对改变的部分进行计算，而不是重新计算整个结果，从而节省资源。）等概念。这些概念的应用会根据上下文的不同而有所不同。例如，在
React 中，可以使用 memo() 和 useMemo()
等内置函数来避免不必要的组件渲染和计算。memo()
可以用来防止组件在父组件渲染时不必要地重新渲染，而 useMemo()
可以用来记忆计算密集型的结果。</p>
<h1 id="避免字符串比较">1. 避免字符串比较</h1>
<p>JavaScript 可以轻松隐藏字符串比较的实际成本。如果需要在 C
语言中比较字符串，你会使用 <code>strcmp(a, b)</code> 函数。JavaScript
使用 <code>===</code> 代替，所以你看不到 <code>strcmp</code>
函数。但它确实存在，字符串比较通常（但并不总是）需要将一个字符串中的每个字符与另一个字符串中的字符进行比较；字符串比较的时间复杂度是
O(n)。一种需要避免的常见 JavaScript 模式是将字符串用作枚举。但随着
TypeScript 的出现，这种情况因该很容易避免，因为枚举默认是整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">enum <span class="title class_">Position</span> &#123;</span><br><span class="line">  <span class="variable constant_">TOP</span> = <span class="string">&#x27;TOP&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span> = <span class="string">&#x27;BOTTOM&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">enum <span class="title class_">Position</span> &#123;</span><br><span class="line">  <span class="variable constant_">TOP</span>, <span class="comment">// = 0</span></span><br><span class="line">  <span class="variable constant_">BOTTOM</span>, <span class="comment">// = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是两者的性能差异：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. string 比较</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Position</span> = &#123;</span><br><span class="line">  <span class="attr">TOP</span>: <span class="string">&quot;TOP&quot;</span>,</span><br><span class="line">  <span class="attr">BOTTOM</span>: <span class="string">&quot;BOTTOM&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> current = i % <span class="number">2</span> === <span class="number">0</span> ? <span class="title class_">Position</span>.<span class="property">TOP</span> : <span class="title class_">Position</span>.<span class="property">BOTTOM</span>;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="title class_">Position</span>.<span class="property">TOP</span>) _ += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. int 比较</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Position</span> = &#123;</span><br><span class="line">  <span class="attr">TOP</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">BOTTOM</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> current = i % <span class="number">2</span> === <span class="number">0</span> ? <span class="title class_">Position</span>.<span class="property">TOP</span> : <span class="title class_">Position</span>.<span class="property">BOTTOM</span>;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="title class_">Position</span>.<span class="property">TOP</span>) _ += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，整数比较比字符串比较快了
1 倍左右。</p>
</blockquote>
<blockquote>
<p>关于基准测试 百分比结果表示在 1
秒内完成的操作数量，除以最高得分案例的操作数量。数值越高越好。</p>
</blockquote>
<p>如你所见，差异可能非常显著。差异不一定是由 <code>strcmp</code>
成本造成的，因为引擎有时可以使用字符串池并通过引用进行比较，但这也是因为在
JS
引擎中整数通常按值传递，而字符串总是作为指针传递，内存访问的成本很高（参见第
5 节）。在大量使用字符串的代码中，这可能会产生巨大的影响。</p>
<p>举一个真实世界的例子，我能够让<a
target="_blank" rel="noopener" href="https://github.com/json5/json5/pull/278">这个 JSON5 JavaScript
解析器的速度提高 2 倍</a>，仅仅通过将字符串常量替换为数字。</p>
<p>*不幸的是它没有被合并，但开源项目就是如此。</p>
<h1 id="避免不同的形状">2.避免不同的形状</h1>
<p>JavaScript
引擎试图通过假设对象具有特定的形状(shape)来优化代码，并且假设函数将接收具有相同形状的对象。这允许它们一次存储该形状的所有对象的键，并在单独的平面数组中存储值。在
JavaScript 中表示如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objects = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Anthony&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">36</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Eckhart&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译注：上面的对象可以表示成下面这种结构，将所有键提取出来，将所有值存储在一个数组中</span></span><br><span class="line"><span class="keyword">const</span> shape = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;name&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;string&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;age&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objects = [</span><br><span class="line">  [<span class="string">&quot;Anthony&quot;</span>, <span class="number">36</span>],</span><br><span class="line">  [<span class="string">&quot;Eckhart&quot;</span>, <span class="number">42</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于术语的解释 我使用了 “形状”
这个词来表达这个概念，但请注意，您可能还看到过使用 “隐藏类（hidden
class）” 或 “映射（map）” 描述它，具体取决于不同的引擎。</p>
</blockquote>
<p>例如，在运行时，如果以下函数接收两个具有形状
<code>&#123; x: number, y: number &#125;</code>
的对象，引擎将推测未来的对象将具有相同的形状，并为该形状生成优化的机器代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: a.<span class="property">x</span> + b.<span class="property">x</span>,</span><br><span class="line">    <span class="attr">y</span>: a.<span class="property">y</span> + b.<span class="property">y</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传递的对象不是形状为 <code>&#123; x, y &#125;</code> 而是形状为
<code>&#123; y, x &#125;</code>
的对象，引擎将需要撤销其推测，而且函数将突然变得相当慢。我不会在这里展开解释，因为你应该阅读
<a
target="_blank" rel="noopener" href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">mraleph
的优秀文章</a>以获取更多细节，但我要强调的是，尤其是 V8 有 3
种模式，对于访问分别是：单态（1 个形状）、多态（2-4 个形状）和超多态（5
个以上形状）。你真的应该保持代码的单态性，因为一旦代码变成多态或超多态，性能下降会非常严重：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">let</span> _ = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 1. 单态</span></span><br><span class="line"><span class="keyword">const</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o4 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o5 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;; <span class="comment">// 所有类型都一样</span></span><br><span class="line"><span class="comment">// 2. 多态</span></span><br><span class="line"><span class="keyword">const</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o4 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o5 = &#123; <span class="attr">b</span>: _, <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;; <span class="comment">// 这个类型与其他类型不同</span></span><br><span class="line"><span class="comment">// 3. 超多态</span></span><br><span class="line"><span class="keyword">const</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123; <span class="attr">b</span>: _, <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123; <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">d</span>: _, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o4 = &#123; <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">e</span>: _ &#125;;</span><br><span class="line"><span class="keyword">const</span> o5 = &#123; <span class="attr">b</span>: _, <span class="attr">c</span>: _, <span class="attr">d</span>: _, <span class="attr">e</span>: _, <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// 所有类型都不一样</span></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1, b1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a1.<span class="property">a</span> + a1.<span class="property">b</span> + a1.<span class="property">c</span> + a1.<span class="property">d</span> + a1.<span class="property">e</span> + b1.<span class="property">a</span> + b1.<span class="property">b</span> + b1.<span class="property">c</span> + b1.<span class="property">d</span> + b1.<span class="property">e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  result += <span class="title function_">add</span>(o1, o2);</span><br><span class="line">  result += <span class="title function_">add</span>(o3, o4);</span><br><span class="line">  result += <span class="title function_">add</span>(o4, o5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，一旦代码变得多态或超多态，性能就会急剧下降。</p>
</blockquote>
<p>应该如何应对这种情况？</p>
<p>说起来容易做起来难，但是：应该<strong>用完全相同的形状创建所有对象</strong>。即使是像<strong>以不同顺序编写
React
组件属性（prop）这样微不足道的事情也可能触发这个问题</strong>。</p>
<p>例如，以下是我在 React 代码库中发现的<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/pull/28569">简单案例</a>，但他们几年前就有一个<a
target="_blank" rel="noopener" href="https://v8.dev/blog/react-cliff">影响更大的案例</a>，他们首先用整数初始化了一个对象，后来又存储了一个浮点数。是的，改变类型也会改变形状。尽管整数和浮点数都是数字（<code>number</code>）类型，但是它们在底层的表示和处理方式是不同的。开发者需要意识到这个问题，并在编写代码时考虑到这一点。</p>
<blockquote>
<p>数字表示 引擎通常可以将整数编码为值。例如，V8 使用 32
位编码来表示值，整数被编码为紧凑的 <a
target="_blank" rel="noopener" href="https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da">Smi</a>
(SMall Integer) 值，但浮点数和大整数则像字符串和对象一样作为指针传递。
JSC 使用 64 位编码、 双标签（<a
target="_blank" rel="noopener" href="https://ktln2.org/2020/08/25/javascriptcore/">double
tagging</a>）来按值传递所有数字，就像 SpiderMonkey
所做的那样，其余的则作为指针传递。</p>
</blockquote>
<h1 id="避免数组-对象方法">3.避免数组 / 对象方法</h1>
<p>我像其他人一样喜欢函数式编程，但除非你使用 Haskell/OCaml/Rust
语言，其函数式代码被编译成高效的机器代码，否则函数式编程总是会比命令式编程慢。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [<span class="number">1.5</span>, <span class="number">3.5</span>, <span class="number">5.0</span>]</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">round</span>(n))</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  .<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, n</span>) =&gt;</span> a + n, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这些方法的问题在于：</p>
<ol type="1">
<li>它们需要完整复制数组，而这些副本后面需要由垃圾收集器释放。我们将在第
5 节更详细地探讨内存 I/O 问题。</li>
<li>它们为 N 个操作循环 N 次，而 for 循环只需要一次循环。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> numbers = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10_000</span> &#125;).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br><span class="line"><span class="comment">// 1. 函数式</span></span><br><span class="line"><span class="keyword">const</span> result = numbers</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">round</span>(n * <span class="number">10</span>))</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  .<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, n</span>) =&gt;</span> a + n, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 命令式</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="title class_">Math</span>.<span class="title function_">round</span>(numbers[i] * <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  result = result + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，命令式比函数式快了差不多
3 倍。</p>
</blockquote>
<p>对象方法如 <code>Object.values()</code>、<code>Object.keys()</code>
和
<code>Object.entries()</code>也有类似的问题，因为它们也分配了更多的数据，而内存访问是所有性能问题的根源。真的，我发誓，我将在第
5 节展示给你看。</p>
<h1 id="避免间接访问">4.避免间接访问</h1>
<p>寻找优化增益的另一个地方是任何间接访问，比如下面 3 个主要来源：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">// 代理对象很难优化，因为它们的 get/set 函数可能运行自定义逻辑，所以引擎不能做出通常的假设。</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(point, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">t, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t[k];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 一些引擎可以使代理成本消失，但这些优化的实现是昂贵的，并且可能很脆弱，容易因为 JavaScript 代码的其他变化或引擎的更新而失效。</span></span><br><span class="line"><span class="keyword">const</span> x = proxy.<span class="property">x</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="comment">// 通常被忽视，但通过 `.` 或 `[]` 访问对象也是间接的。在简单的情况下，引擎可以很好地优化掉这个成本：</span></span><br><span class="line"><span class="keyword">const</span> x = point.<span class="property">x</span>;</span><br><span class="line"><span class="comment">// 但每次额外的访问都会增加成本，并使引擎更难对 `point` 的状态做出假设：</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">circle</span>.<span class="property">center</span>.<span class="property">point</span>.<span class="property">x</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="comment">// 最后，函数调用也有成本。引擎通常擅长通过内联优化<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="内联（Inlining）是一种优化技术，JavaScript 引擎（如 V8、SpiderMonkey、JavaScriptCore 等）使用这种技术来减少函数调用的开销。通过内联，引擎可以将函数的代码直接插入到调用该函数的地方，从而避免了函数调用的额外开销。内联优化通常在以下情况下效果最好：当函数体较小且被频繁调用时，或者函数调用发生在热点代码（即执行非常频繁的代码段）中时。
">[2]</span></a></sup>来减少这种成本：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getX</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> p.<span class="property">x</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> x = <span class="title function_">getX</span>(p);</span><br><span class="line"><span class="comment">// 但并不能保证他们一定可以。特别是如果函数调用不是来自静态函数而是来自参数：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">&#123; point, getX &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getX</span>(point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理性能基准测试目前对 V8
引擎来说特别具有挑战性。上次我检查的时候，代理对象总是从即时编译器（JIT）<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span
class="hint--top hint--error hint--medium hint--rounded hint--bounce"
aria-label="JIT（Just-In-Time）编译器是一种在程序运行时将源代码编译成机器代码的技术，它可以提高程序的执行速度。解释器（interpreter）是一种逐行或逐句执行源代码的程序，通常比 JIT 编译器慢，因为它没有进行优化的编译过程
">[3]</span></a></sup>回退到解释器，从那些结果来看，现在可能还是这种情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 代理访问</span></span><br><span class="line"><span class="keyword">const</span> point = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;, &#123; <span class="attr">get</span>: <span class="function">(<span class="params">t, k</span>) =&gt;</span> t[k] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">  _ += point.<span class="property">x</span>;</span><br><span class="line">&#125;</span><br><span class="line">javascript;</span><br><span class="line"><span class="comment">// 2. 直接访问</span></span><br><span class="line"><span class="keyword">const</span> point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> x = point.<span class="property">x</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">  _ += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，直接访问比代理访问快了差不多
50 倍。</p>
</blockquote>
<p>我还想要展示访问深层嵌套对象与直接访问对象之间的差异，但引擎非常擅长在存在热循环<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span
class="hint--top hint--error hint--medium hint--rounded hint--bounce"
aria-label="当存在一个 热循环（即执行非常频繁的循环）和一个 常量对象（即对象在循环过程中没有改变）时，引擎可以通过逃逸分析来优化对象的访问。这种优化可能会减少访问对象属性时的性能开销。
">[4]</span></a></sup>和常量对象时，通过逃逸分析<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span
class="hint--top hint--error hint--medium hint--rounded hint--bounce"
aria-label="逃逸分析是 JavaScript 引擎用来确定对象是否在当前作用域之外被引用的一种分析技术。如果一个对象在循环中被频繁访问，且对象本身没有被外部引用（即没有逃逸出当前作用域），引擎可能会对这个对象进行优化。
">[5]</span></a></sup>来优化对象访问。我加入了一些间接访问来防止这种优化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 嵌套访问</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">state</span>: &#123; <span class="attr">center</span>: &#123; <span class="attr">point</span>: &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125; &#125; &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">state</span>: &#123; <span class="attr">center</span>: &#123; <span class="attr">point</span>: &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125; &#125; &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">i</span>) =&gt; (i % <span class="number">2</span> ? a : b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">  result = result + <span class="title function_">get</span>(i).<span class="property">state</span>.<span class="property">center</span>.<span class="property">point</span>.<span class="property">x</span>;</span><br><span class="line">&#125;</span><br><span class="line">javascript;</span><br><span class="line"><span class="comment">// 2. 直接访问</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;.<span class="property">x</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;.<span class="property">x</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">i</span>) =&gt; (i % <span class="number">2</span> ? a : b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">  result = result + <span class="title function_">get</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，直接访问比嵌套访问快了差不多
2 倍。</p>
</blockquote>
<h1 id="避免缓存未命中">5.避免缓存未命中</h1>
<p>这一节需要一些底层知识， JavaScript
是一门高级语言，运行在虚拟机或解释器上，但底层的内存访问模式仍然对性能有影响。从
CPU 的角度来看，从 RAM
中检索内存的速度很慢。为了加快速度，它主要使用两种优化技术。</p>
<h2 id="预取">5.1 预取</h2>
<p>第一种是预取技术：它会提前获取更多的内存，希望这些是你接下来会感兴趣的内存。它总是猜测，如果你请求了一个内存地址，你可能会对紧随其后的内存区域感兴趣。所以<strong>顺序访问数据</strong>是关键。在下面的示例中，我们可以观察到以随机顺序访问内存的影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> K = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> length = <span class="number">1</span> * K * K;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些点是依次创建的，因此它们在内存中是顺序分配的。</span></span><br><span class="line"><span class="keyword">const</span> points = <span class="keyword">new</span> <span class="title class_">Array</span>(length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; points.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  points[i] = &#123; <span class="attr">x</span>: <span class="number">42</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个数组包含了与上面相同的数据，但是被随机打乱了。</span></span><br><span class="line"><span class="keyword">const</span> shuffledPoints = <span class="title function_">shuffle</span>(points.<span class="title function_">slice</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 顺序</span></span><br><span class="line"><span class="keyword">let</span> _ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; points.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  _ += points[i].<span class="property">x</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 随机</span></span><br><span class="line"><span class="keyword">let</span> _ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shuffledPoints.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  _ += shuffledPoints[i].<span class="property">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，顺序访问比随机访问快了差不多
7 倍。</p>
</blockquote>
<p>应该如何应对这种情况？</p>
<p>这个方面可能是最难实践的，因为 JavaScript
没有一种方式来指定对象在内存中的位置。但是，你可以利用这些知识来发挥优势，就像上面的例子一样，例如在重新排序或排序之前对数据进行操作。你不能假设顺序创建的对象在一段时间后还会保持在相同的位置，因为垃圾回收器可能会四处移动它们。有一个例外，那就是数字数组，，最好是
<code>TypedArray</code> 实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从这样</span></span><br><span class="line"><span class="keyword">const</span> points = [</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">10</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这样</span></span><br><span class="line"><span class="keyword">const</span> points = <span class="keyword">new</span> <span class="title class_">Int64Array</span>([<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p>更多详细案例，请参考这个<a
target="_blank" rel="noopener" href="https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html#optimizing-parsing---reducing-gc-pressure">链接</a>。</p>
<p>*请注意，虽然它包含一些现已过时的优化，但总体而言仍然准确。</p>
<h2 id="l123-缓存">5.2 L1/2/3 缓存</h2>
<p>CPU 使用的第二种优化是 L1/L2/L3 缓存：这些缓存就像是更快的
RAM，但它们也更昂贵，因此容量要小得多。它们包含了 RAM
中的数据，但像最近最少使用（LRU）缓存一样工作。数据在 “热”
的时候（正在被处理）进入缓存，并在需要空间来装载新的工作数据时被写回主
RAM。所以关键是尽可能少地使用数据，以保持你的工作数据集在快速缓存中。在下面的例子中，我们可以观察到破坏每一个连续缓存的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">KB</span> = <span class="number">1024</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MB</span> = <span class="number">1024</span> \* <span class="variable constant_">KB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些是适应这些缓存的大致大小。如果你的机器上没有得到相同的结果，可能是因为你的 L1/L2/L3 大小不同。</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">L1</span>  = <span class="number">256</span> * <span class="variable constant_">KB</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">L2</span>  =   <span class="number">5</span> * <span class="variable constant_">MB</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">L3</span>  =  <span class="number">18</span> * <span class="variable constant_">MB</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RAM</span> =  <span class="number">32</span> * <span class="variable constant_">MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将在所有测试用例中访问同一个缓冲区，但我们只在第一个用例中访问前 0 到 L1 条目，</span></span><br><span class="line"><span class="comment">// 在第二个用例中访问 0 到 L2 条目，依此类推</span></span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(<span class="variable constant_">RAM</span>)</span><br><span class="line">buffer.<span class="title function_">fill</span>(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">random</span> = (<span class="params">max</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() \* max)</span><br><span class="line">javascript</span><br><span class="line"><span class="comment">// 1. L1</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; r += buffer[<span class="title function_">random</span>(<span class="variable constant_">L1</span>)] &#125;</span><br><span class="line">javascript</span><br><span class="line"><span class="comment">// 2. L2</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; r += buffer[<span class="title function_">random</span>(<span class="variable constant_">L2</span>)] &#125;</span><br><span class="line">javascript</span><br><span class="line"><span class="comment">// 3. L3</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; r += buffer[<span class="title function_">random</span>(<span class="variable constant_">L3</span>)] &#125;</span><br><span class="line">javascript</span><br><span class="line"><span class="comment">// 4. RAM</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; r += buffer[<span class="title function_">random</span>(<span class="variable constant_">RAM</span>)] &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，L1
访问速度最快，RAM 访问速度最慢。</p>
</blockquote>
<p>应该如何应对这种情况？</p>
<p><strong>无情地消除每一个可以消除的数据或内存</strong>分配。你的数据集越小，你的程序运行得越快。内存
I/O 是 95%
程序的瓶颈。另一种好的策略是将你的工作分成块，并确保你一次只处理一个小数据集。</p>
<p>有关 CPU 和内存的更多详细信息，请参阅此<a
target="_blank" rel="noopener" href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf">链接</a>。</p>
<blockquote>
<p>关于不可变数据结构
不可变性对于清晰性和正确性来说非常有用，但在性能方面，更新不可变数据结构意味着创建容器的副本，这就需要更多的内存
I/O，可能会清除你的缓存。在可能的情况下，你应该避免使用不可变数据结构。</p>
</blockquote>
<blockquote>
<p>关于展开运算符 { …spread }
它非常方便，但每次使用它时都会在内存中创建一个新对象。更多内存
I/O，更慢的缓存！</p>
</blockquote>
<h1 id="避免大型对象">6.避免大型对象</h1>
<p>正如第 2
节所解释的，引擎使用形状来优化对象。然而，当形状变得太大时，引擎别无选择，只能使用常规
hashmap （如 <code>Map</code> 对象）。正如我们在第 5
节所看到的，缓存未命中会显著降低性能。Hashmap
由于其数据通常随机且均匀分布在它们所占据的内存区域，因此容易受到这种影响。让我们看看这个按
ID 索引的一些用户的映射如何表现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">USERS_LENGTH</span> = <span class="number">1_000</span>;</span><br><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> byId = &#123;&#125;;</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="variable constant_">USERS_LENGTH</span> &#125;).<span class="title function_">forEach</span>(<span class="function">(<span class="params">_, id</span>) =&gt;</span> &#123;</span><br><span class="line">  byId[id] = &#123; id, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> _ = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 1. [] 访问</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(byId).<span class="title function_">forEach</span>(<span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  _ += byId[id].<span class="property">id</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2. 直接访问</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(byId).<span class="title function_">forEach</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  _ += user.<span class="property">id</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，直接访问比
[] 访问快了差不多 2 倍。</p>
</blockquote>
<p>我们也可以观察到，随着对象大小的增长，性能如何持续下降：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">USERS_LENGTH</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，当
USERS_LENGTH 的值为 100000 时，直接访问比 [] 访问快了差不多 5 倍。</p>
</blockquote>
<p>应该如何应对这种情况？</p>
<p>如上所述，避免频繁索引大型对象。最好事先将对象转换为数组。将 ID
作为模型的一部分来组织数据会很有帮助，因为你可以直接使用 Object.values()
方法，而不需要通过键映射来获取 ID。</p>
<h1 id="使用-eval">7.使用 eval</h1>
<p>一些 JavaScript 模式对引擎来说很难优化，通过使用 <code>eval()</code>
或其衍生产品，你可以使这些模式消失。在这个例子中，我们可以看到使用
<code>eval()</code> 避免了创建具有动态对象键的对象的成本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;requestId&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">100_000</span> &#125;).<span class="title function_">fill</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 1. 不使用 eval</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMessages</span>(<span class="params">key, values</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> messages = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    messages.<span class="title function_">push</span>(&#123; [key]: values[i] &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> messages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createMessages</span>(key, values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 eval</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMessages</span>(<span class="params">key, values</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> messages = [];</span><br><span class="line">  <span class="keyword">const</span> createMessage = <span class="keyword">new</span> <span class="title class_">Function</span>(</span><br><span class="line">    <span class="string">&quot;value&quot;</span>,</span><br><span class="line">    <span class="string">`return &#123; <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span>: value &#125;`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    messages.<span class="title function_">push</span>(<span class="title function_">createMessage</span>(values[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> messages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createMessages</span>(key, values);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，使用
<code>eval</code> 比不使用 <code>eval</code> 快了差不多 2 倍。</p>
</blockquote>
<p>eval
的另一个好的用例是编译一个过滤谓词函数<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span
class="hint--top hint--error hint--medium hint--rounded hint--bounce"
aria-label="谓词函数是一个返回布尔值的函数，通常用于判断某个条件是否满足。
">[6]</span></a></sup>，你可以丢弃那些你知道永远不会执行的分支。一般来说，任何将在热循环<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span
class="hint--top hint--error hint--medium hint--rounded hint--bounce"
aria-label="热循环（hot loop）是指在程序中执行非常频繁的循环。在这种情况下，循环体内的代码性能至关重要。
">[7]</span></a></sup>中运行的函数都适合这种优化。</p>
<p>显然，关于使用 <code>eval()</code>
的常见警告同样适用：不要信任用户输入，净化任何传递给 <code>eval()</code>
代码中的内容，并且不要创建任何跨站脚本攻击
（XSS）可能性。还要注意，有些环境不允许访问
<code>eval()</code>，例如带有内容安全策略(CSP)的浏览器页面。</p>
<h1 id="谨慎使用字符串">8.谨慎使用字符串</h1>
<p>我们已经看到，字符串比它们看起来的成本更高。好吧，我这里有一个好消息和一个坏消息，让我们按逻辑顺序（坏消息优先，好消息其次）讲吧：字符串比它们看起来的更复杂，但如果使用得当，它们也可以非常高效。</p>
<p>由于其使用场景，字符串操作是 JavaScript
的核心部分。为了优化字符串密集型代码，引擎必须具有创造性。我的意思是，它们必须根据不同的用例，在
C++
中以多种字符串表示形式来表示字符串对象。你应该关注两种通用情况，因为它们对于
V8（迄今为止最常用的引擎）是成立的，通常也适用于其他引擎。</p>
<p>首先，使用 +
连接的字符串不会创建两个输入字符串的副本。该操作创建一个指向每个子字符串的指针。如果是在
TypeScript 中，它可能是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">  abstract <span class="title function_">value</span>(): char[] &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BytesString</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">bytes: char[]</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bytes</span> = bytes</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">value</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">bytes</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcatenatedString</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">left: <span class="built_in">String</span>, right: <span class="built_in">String</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">value</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">value</span>(), ...<span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">value</span>()]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">concat</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcatenatedString</span>(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> first = <span class="keyword">new</span> <span class="title class_">BytesString</span>([<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> second = <span class="keyword">new</span> <span class="title class_">BytesString</span>([<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看这里, 没有数组复制！</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">concat</span>(first, second)</span><br></pre></td></tr></table></figure>
<p>其次，字符串切片也不需要创建副本：它们可以简单地指向另一个字符串中的范围。继续上面的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SlicedString</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">source: <span class="built_in">String</span>, start: number, end: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">source</span> = source;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">start</span> = start;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">end</span> = end;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">value</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">source</span>.<span class="title function_">value</span>().<span class="title function_">slice</span>(<span class="variable language_">this</span>.<span class="property">start</span>, <span class="variable language_">this</span>.<span class="property">end</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">substring</span>(<span class="params">source, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SlicedString</span>(source, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 &quot;He&quot;，但它仍然不包含数组副本。</span></span><br><span class="line"><span class="comment">// 它是从 ConcatenatedString 到 SlicedString 的两个 BytesString</span></span><br><span class="line"><span class="keyword">const</span> firstTwoLetters = <span class="title function_">substring</span>(message, <span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>但问题是：一旦你需要改变这些字节，那就是你开始支付复制成本的时刻。让我们回到我们的
<code>String</code> 类，尝试添加一个<code>.trimEnd</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">  abstract <span class="title function_">value</span>(): char[] &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">trimEnd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 value() 方法时可能会涉及到一个经过切片（Sliced）、拼接（Concatenated）和两倍字节（2*Bytes）处理的字符串</span></span><br><span class="line">    <span class="keyword">const</span> bytes = <span class="variable language_">this</span>.<span class="title function_">value</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = bytes.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">while</span> (result[result.<span class="property">length</span> - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      result.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BytesString</span>(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看这个例子，该例中我们比较使用变异（Mutation）与只使用连接（Concatenation）的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> classNames = [<span class="string">&quot;primary&quot;</span>, <span class="string">&quot;selected&quot;</span>, <span class="string">&quot;active&quot;</span>, <span class="string">&quot;medium&quot;</span>];</span><br><span class="line"><span class="comment">// 1. 变异</span></span><br><span class="line"><span class="keyword">const</span> result = classNames.<span class="title function_">map</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> <span class="string">`button--<span class="subst">$&#123;c&#125;</span>`</span>).<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 2. 连接</span></span><br><span class="line"><span class="keyword">const</span> result = classNames</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> <span class="string">&quot;button--&quot;</span> + c)</span><br><span class="line">  .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, c</span>) =&gt;</span> acc + <span class="string">&quot; &quot;</span> + c, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，使用连接比使用变异快了差不多
3 倍。</p>
</blockquote>
<p>应该如何应对这种情况？</p>
<p>总的来说，尽量<strong>尽可能长时间地避免变异操作</strong>。这包括
<code>.trim()</code>、<code>.replace()</code>
等方法。思考如何可以避免使用这些方法。在一些引擎中，字符串模板也可能比 +
慢。目前在 V8 中是这样，但未来可能不是，所以总是进行基准测试。</p>
<p>关于上面的
<code>SlicedString</code>，你应该注意的是，如果一个非常大的字符串中的一个小子字符串在内存中存活，它可能会阻止垃圾回收集器回收大字符串！如果你正在处理大型文本并从中提取小字符串，你可能会泄露大量的内存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> large = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10_000</span> &#125;)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="string">&quot;string&quot;</span>)</span><br><span class="line">  .<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> small = large.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// small 将会使 large 保持存活</span></span><br></pre></td></tr></table></figure>
<p>这里的解决方案是使用对我们有利的变异方法。如果我们在
<code>small</code>
上使用其中一个变异方法，它将强制创建一个新的副本，并且指向
<code>large</code> 的旧指针将丢失：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换一个不存在的 token</span></span><br><span class="line"><span class="keyword">const</span> small = small.<span class="title function_">replace</span>(<span class="string">&quot;#&quot;</span>.<span class="title function_">repeat</span>(small.<span class="property">length</span> + <span class="number">1</span>), <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>更多详细信息，请参阅 <a
target="_blank" rel="noopener" href="https://github.com/v8/v8/blob/main/src/objects/string.h">V8 上的
string.h</a> 或 <a
target="_blank" rel="noopener" href="https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/runtime/JSString.h">JavaScriptCore
上的 JSString.h</a>。</p>
<blockquote>
<p>关于字符串的复杂性
我非常快速地浏览了这些内容，但是有很多实现细节增加了字符串的复杂性。每种字符串表示形式通常都有最小长度限制。例如，连接字符串可能不适用于非常小的字符串。或者有时会有一些限制，比如避免指向一个子串的子串。阅读上面链接的
C++ 文件可以很好地了解这些实现细节，哪怕只是读读注释也好。</p>
</blockquote>
<h1 id="使用专门化">9.使用专门化</h1>
<p>性能优化中的一个重要概念是 <em>专门化</em>
：根据特定用例的约束调整你的逻辑。这通常意味着弄清楚哪些条件对你的案例
<em>可能</em> 是真的，并为这些条件编码。</p>
<p>假设我们是一个商户，有时需要给产品列表添加标签。我们从经验中知道，我们的标签通常是空的。了解到这个信息，我们可以为那个案例专门化我们的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> descriptions = [<span class="string">&quot;apples&quot;</span>, <span class="string">&quot;oranges&quot;</span>, <span class="string">&quot;bananas&quot;</span>, <span class="string">&quot;seven&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> someTags = &#123;</span><br><span class="line">  <span class="attr">apples</span>: <span class="string">&quot;::promotion::&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> noTags = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将产品信息转换为字符串，同时包含可用的标签</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">productsToString</span>(<span class="params">description, tags</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  description.<span class="title function_">forEach</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> &#123;</span><br><span class="line">    result += product;</span><br><span class="line">    <span class="keyword">if</span> (tags[product]) result += tags[product];</span><br><span class="line">    result += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上述代码做专门化处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">productsToStringSpecialized</span>(<span class="params">description, tags</span>) &#123;</span><br><span class="line">  <span class="comment">// 我们知道 tags 很可能是空的，所以我们提前检查一次，</span></span><br><span class="line">  <span class="comment">// 然后我们可以在内部循环中移除 if 检查。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isEmpty</span>(tags)) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    description.<span class="title function_">forEach</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> &#123;</span><br><span class="line">      result += product + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    description.<span class="title function_">forEach</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> &#123;</span><br><span class="line">      result += product;</span><br><span class="line">      <span class="keyword">if</span> (tags[product]) result += tags[product];</span><br><span class="line">      result += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 未作专门化处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">productsToString</span>(descriptions, someTags);</span><br><span class="line">  <span class="title function_">productsToString</span>(descriptions, noTags);</span><br><span class="line">  <span class="title function_">productsToString</span>(descriptions, noTags);</span><br><span class="line">  <span class="title function_">productsToString</span>(descriptions, noTags);</span><br><span class="line">  <span class="title function_">productsToString</span>(descriptions, noTags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 专门化处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">productsToStringSpecialized</span>(descriptions, someTags);</span><br><span class="line">  <span class="title function_">productsToStringSpecialized</span>(descriptions, noTags);</span><br><span class="line">  <span class="title function_">productsToStringSpecialized</span>(descriptions, noTags);</span><br><span class="line">  <span class="title function_">productsToStringSpecialized</span>(descriptions, noTags);</span><br><span class="line">  <span class="title function_">productsToStringSpecialized</span>(descriptions, noTags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，专门化处理后比未作专门化处理快了差不多
1.2 倍。</p>
</blockquote>
<p>虽然这种类型的优化只能提供适度的改进，但这些改进会累积起来。它们是对更重要的优化（如形状和内存
I/O）的一个很好的补充。但请注意，如果条件发生变化，专门化可能会对你不利，所以应该谨慎使用。</p>
<blockquote>
<p>分支预测和无分支代码
对于性能来说，从你的代码中移除分支可以极大地提高效率。要了解更多关于分支预测器的信息，请阅读
Stack Overflow 上的经典回答 <a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array">为什么处理一个已排序的数组会更快</a>。</p>
</blockquote>
<h1 id="数据结构">10.数据结构</h1>
<p>我不会详细讨论数据结构，因为这部分内容太多需要单独的帖子。但请注意为你的用例使用错误的数据结构可能会产生比<strong>上述任何优化都更大的影响</strong>。我建议你熟悉像
<code>Map</code> 和 <code>Set</code>
这样的原生数据结构，并且学习链表、优先队列、树（RB 和
B+）并亲自尝试。</p>
<p>举一个简单的例子，让我们比较 <code>Array.includes</code> 与
<code>Set.has</code> 对于一个小列表的表现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化:</span></span><br><span class="line"><span class="keyword">const</span> userIds = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">1_000</span> &#125;).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="keyword">const</span> adminIdsArray = userIds.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> adminIdsSet = <span class="keyword">new</span> <span class="title class_">Set</span>(adminIdsArray);</span><br><span class="line"><span class="comment">// 1. Array</span></span><br><span class="line"><span class="keyword">let</span> _ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; userIds.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (adminIdsArray.<span class="title function_">includes</span>(userIds[i])) &#123;</span><br><span class="line">    _ += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. Set</span></span><br><span class="line"><span class="keyword">let</span> _ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; userIds.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (adminIdsSet.<span class="title function_">has</span>(userIds[i])) &#123;</span><br><span class="line">    _ += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注：博客原文这里可以直接运行测试代码，此处省略。测试结果表明，Set
比 Array 快了差不多 3 倍。</p>
</blockquote>
<p>如你所见，数据结构的选择会产生非常显著的差异。</p>
<p>作为一个真实世界的例子，我们曾经通过将数组换成链表，<a
target="_blank" rel="noopener" href="https://github.com/mui/mui-x/pull/9200">将一个函数的运行时间从 5
秒减少到 22 毫秒</a>。</p>
<h1 id="基准测试">11.基准测试</h1>
<p>我把这部分留到最后有一个原因：我需要用上面有趣的部分建立信誉。现在我希望已经赢得了你的信任，我要告诉你基准测试是优化中最重要的部分。它不仅是最重要的，而且也是
<em>困难的</em> 。即使拥有 20
年的经验，我有时也会创建有缺陷的基准测试，或者错误地使用分析工具。所以无论你做什么，请把<strong>最大的努力放在正确地使用基准测试上</strong>。</p>
<h2 id="从大块开始">11.0 从大块开始</h2>
<p>你应该始终优先优化占你程序运行时间最大部分的函数或代码段。如果你花费时间优化其他非关键部分，那么就是在浪费时间。</p>
<h2 id="避免微基准测试">11.1 避免微基准测试</h2>
<p>在生产模式下运行你的代码，并基于这些观察进行优化。JavaScript
引擎非常复杂，并且在微基准测试<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span
class="hint--top hint--error hint--medium hint--rounded hint--bounce"
aria-label="微基准测试（Microbenchmarking）是一种性能测试方法，它专注于测量代码的非常小片段的执行时间。这种方法通常用于评估和比较特定操作的性能，如函数调用、数据访问、算法实现等。
">[8]</span></a></sup>中的表现通常与在现实场景中不同。例如，看这个微基准测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>, <span class="attr">count</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">type</span>: <span class="string">&quot;span&quot;</span>, <span class="attr">count</span>: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">typeEquals</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">type</span> === b.<span class="property">type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">typeEquals</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你认真看了上面的内容，你会意识到引擎将为形状
<code>&#123; type: string, count: number &#125;</code>
专门化这个函数。但在你的真实世界用例中，这是否成立？<code>a</code> 和
<code>b</code>
是否总是那种形状，还是会收到任何形状？如果你在生产环境中收到许多形状，这个函数的表现将会不同。</p>
<h2 id="怀疑你结果">11.2 怀疑你结果</h2>
<p>如果你刚刚优化完一个函数，它现在运行立马快了 100
倍，请对此表示怀疑。试着反驳你的结果，试着在生产模式下测试它，尝试传递不同的参数。同时，怀疑你的测试工具。仅仅使用开发工具观察基准测试就可以改变其行为。</p>
<h2 id="选择你的目标">11.3 选择你的目标</h2>
<p>不同的引擎会比其他引擎更好或更差地优化某些模式。你应该为你相关的引擎进行基准测试，并确定哪一个更重要。这是
Babel 的<a
target="_blank" rel="noopener" href="https://github.com/babel/babel/pull/16357">一个真实实例</a>，其中改进
V8 意味着降低 JSC 的性能。</p>
<h1 id="分析和工具">12.分析和工具</h1>
<p>关于分析和开发工具的各种评论。</p>
<h2 id="浏览器陷阱">12.1 浏览器陷阱</h2>
<p>如果你在浏览器中进行分析，请确保使用一个干净且空的浏览器配置文件。我甚至为此使用一个单独的浏览器。如果你在分析时启用了浏览器扩展，它们可能会干扰测量结果。特别是
React DevTools 会显著影响结果，使得代码渲染可能比你用户感知的要慢。</p>
<h2 id="采样与结构化分析">12.2 采样与结构化分析</h2>
<p>浏览器分析工具是基于采样的分析器，它们定期对堆栈进行采样。这有一个很大缺点：一些非常小但非常频繁的函数可能在这些样本之间被调用，并且可能在你会得到的堆栈图表中被严重低估。可以使用
Firefox 开发工具自定义采样间隔或 Chrome 开发工具的 CPU
节流来缓解这个问题。</p>
<h2 id="行业工具">12.3 行业工具</h2>
<p>除了常规的浏览器开发工具，了解以下这些选项可能会有所帮助：</p>
<ul>
<li><p>Chrome devtools 有一些非常有用的实验性标志（Experimental
flags），可以帮助你弄清楚为什么事情会变慢。样式失效跟踪器在调试浏览器中的样式
/ 布局重新计算时是无价的。
https://github.com/iamakulov/devtools-perf-features</p></li>
<li><p>deoptexplorer-vscode 扩展允许你加载 V8/chromium
日志文件，以了解你的代码何时触发去优化（deoptimizations），例如当你将不同的形状传递给函数时。你不需要这个扩展来读取日志文件，但使用它会使体验更加愉快。
https://github.com/microsoft/deoptexplorer-vscode</p></li>
<li><p>你可以随时编译每个 JS 引擎的调试
shell，以更详细地了解它的工作原理。这允许你运行 <code>perf</code>
和其他低级工具，还可以检查每个引擎生成的字节码和机器码。 <a
target="_blank" rel="noopener" href="https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html#getting-the-code">V8
的示例</a> | <a
target="_blank" rel="noopener" href="https://zon8.re/posts/jsc-internals-part1-tracing-js-source-to-bytecode/">JSC
的示例</a> | SpiderMonkey 的示例（缺失）</p></li>
</ul>
<h1 id="后记">后记</h1>
<p>希望你们学到了有用的技巧。如果你有任何评论、更正或疑问，请在页脚的电子邮件中告诉我。我总是乐于收到读者的反馈或问题。</p>
<p>如果你已经读到这里，我邀请你参观 <a
target="_blank" rel="noopener" href="https://romgrk.com/castle">The Castle</a>。</p>
<div id="footnotes">
<hr>
<div id="footnotelist">
<ol style="list-style: none; padding-left: 0; margin-left: 40px">
<li id="fn:1">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span
style="display: inline-block; vertical-align: top; margin-left: 10px;">Brave
122 on Arch Linux 指的是在 Arch Linux 操作系统上运行的 Brave 浏览器版本
122。Brave
是一款注重隐私保护的网络浏览器，它通过屏蔽广告和追踪器来提高用户的隐私安全和浏览速度。<a href="#fnref:1" rev="footnote">
↩︎</a></span>
</li>
<li id="fn:2">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span
style="display: inline-block; vertical-align: top; margin-left: 10px;">内联（Inlining）是一种优化技术，JavaScript
引擎（如 V8、SpiderMonkey、JavaScriptCore
等）使用这种技术来减少函数调用的开销。通过内联，引擎可以将函数的代码直接插入到调用该函数的地方，从而避免了函数调用的额外开销。内联优化通常在以下情况下效果最好：当函数体较小且被频繁调用时，或者函数调用发生在热点代码（即执行非常频繁的代码段）中时。<a href="#fnref:2" rev="footnote">
↩︎</a></span>
</li>
<li id="fn:3">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span
style="display: inline-block; vertical-align: top; margin-left: 10px;">JIT（Just-In-Time）编译器是一种在程序运行时将源代码编译成机器代码的技术，它可以提高程序的执行速度。解释器（interpreter）是一种逐行或逐句执行源代码的程序，通常比
JIT
编译器慢，因为它没有进行优化的编译过程<a href="#fnref:3" rev="footnote">
↩︎</a></span>
</li>
<li id="fn:4">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span
style="display: inline-block; vertical-align: top; margin-left: 10px;">当存在一个
热循环（即执行非常频繁的循环）和一个
常量对象（即对象在循环过程中没有改变）时，引擎可以通过逃逸分析来优化对象的访问。这种优化可能会减少访问对象属性时的性能开销。<a href="#fnref:4" rev="footnote">
↩︎</a></span>
</li>
<li id="fn:5">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span
style="display: inline-block; vertical-align: top; margin-left: 10px;">逃逸分析是
JavaScript
引擎用来确定对象是否在当前作用域之外被引用的一种分析技术。如果一个对象在循环中被频繁访问，且对象本身没有被外部引用（即没有逃逸出当前作用域），引擎可能会对这个对象进行优化。<a href="#fnref:5" rev="footnote">
↩︎</a></span>
</li>
<li id="fn:6">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span
style="display: inline-block; vertical-align: top; margin-left: 10px;">谓词函数是一个返回布尔值的函数，通常用于判断某个条件是否满足。<a href="#fnref:6" rev="footnote">
↩︎</a></span>
</li>
<li id="fn:7">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span
style="display: inline-block; vertical-align: top; margin-left: 10px;">热循环（hot
loop）是指在程序中执行非常频繁的循环。在这种情况下，循环体内的代码性能至关重要。<a href="#fnref:7" rev="footnote">
↩︎</a></span>
</li>
<li id="fn:8">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span
style="display: inline-block; vertical-align: top; margin-left: 10px;">微基准测试（Microbenchmarking）是一种性能测试方法，它专注于测量代码的非常小片段的执行时间。这种方法通常用于评估和比较特定操作的性能，如函数调用、数据访问、算法实现等。<a href="#fnref:8" rev="footnote">
↩︎</a></span>
</li>
</ol>
</div>
</div>
</div>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.JPG" alt="toypipi 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.JPG" alt="toypipi 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>toypipi
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://toypipi.github.io/2024/09/13/%E7%B2%BE%E8%BF%9B-JavaScript-%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BA%AB%E5%8F%97%E4%B9%90%E8%B6%A3%EF%BC%8C%E6%94%B6%E8%8E%B7%E5%88%A9%E6%B6%A6-%E8%AF%91/" title="精进 JavaScript 技术，享受乐趣，收获利润[译]">https://toypipi.github.io/2024/09/13/精进-JavaScript-技术，享受乐趣，收获利润-译/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 前端</a>
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
              <a href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" rel="tag"><i class="fa fa-tag"></i> 代码优化</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/09/11/JavaScript-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E9%97%AD%E5%8C%85-%E8%AF%91/" rel="prev" title="JavaScript 中的垃圾回收和闭包[译]">
                  <i class="fa fa-angle-left"></i> JavaScript 中的垃圾回收和闭包[译]
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/09/19/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%A1%E7%AE%97%E9%A2%98%E6%B1%87%E6%80%BB/" rel="next" title="系统架构师计算题汇总">
                  系统架构师计算题汇总 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">toypipi</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">237k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:21</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"toypipi/BlogComments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
